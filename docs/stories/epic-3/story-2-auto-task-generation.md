# User Story: Auto Task Generation & Workflow Triggers

**Story ID:** STORY-3.2
**Epic:** Epic 3 - Advanced Automation Features
**Feature:** FR14 (Auto Task Generation) + FR18 (Workflow Triggers)
**Priority:** High
**Effort:** 4-5 days
**Status:** Ready for Development

---

## User Story

**As a** practice manager
**I want** automated task generation from templates triggered by service activation and workflow completion
**So that** I eliminate manual task creation and complete the automation loop

---

## Business Value

- **Efficiency:** Eliminates manual task creation (saves 2 hours/week per practice)
- **Consistency:** Ensures all required tasks are created for every service activation
- **Automation Loop:** Workflow completion automatically triggers next stage tasks
- **Accuracy:** Prevents forgotten tasks through automated generation

---

## Acceptance Criteria

### Functional Requirements - Auto Task Generation (FR14)

**AC1: Service Activation Trigger**
- **Given** a service is activated (status → "active")
- **When** activation completes
- **Then** all templates assigned to that service are queried
- **And** tasks are generated from each template
- **And** success notification is shown: "5 tasks generated from templates"

**AC2: Placeholder Replacement**
- **Given** a task is generated from template
- **When** task creation runs
- **Then** placeholders are replaced with actual values:
  - `{client_name}` → client.companyName
  - `{service_name}` → service.name
  - `{company_number}` → client.companiesHouseNumber
  - `{period}` → current quarter or month
  - `{tax_year}` → calculated from activation date

**AC3: Due Date Calculation**
- **Given** a template has due date offset
- **When** task is generated
- **Then** due date is calculated: activationDate + offsetMonths + offsetDays
- **And** target date is calculated: dueDate - 7 days
- **And** dates are stored in task record

**AC4: Task Deduplication**
- **Given** tasks are being generated
- **When** deduplication check runs
- **Then** existing tasks are checked by (clientId, serviceId, task name)
- **And** duplicate tasks are skipped
- **And** summary shows: "5 tasks generated, 2 skipped (duplicates)"

**AC5: Recurring Task Support**
- **Given** a template has `isRecurring = true`
- **When** task generation runs
- **Then** multiple tasks are generated for future periods (e.g., Q1, Q2, Q3, Q4)
- **And** number of periods is configurable (default: 4 quarters ahead)
- **And** each task has correct period placeholder replacement

**AC6: Auto-Assignment**
- **Given** tasks are generated
- **When** task assignment logic runs
- **Then** tasks are assigned to client manager (client.assignedToId)
- **And** if client manager is null, tasks are assigned to template.defaultAssignee
- **And** if both are null, tasks remain unassigned

**AC7: Task Metadata Tracking**
- **Given** a task is auto-generated
- **When** task creation completes
- **Then** task metadata includes:
  - `autoGenerated = true`
  - `templateId = [template ID]`
  - `serviceId = [service ID]`
  - `generatedAt = [current timestamp]`
- **And** metadata enables audit trail and reporting

**AC8: Generate Tasks Button**
- **Given** a user views service detail page
- **When** the page loads
- **Then** "Generate Tasks" button is visible
- **And** clicking button opens generation preview modal
- **And** confirming preview generates tasks from templates

**AC9: Generation Preview**
- **Given** "Generate Tasks" button is clicked
- **When** preview modal opens
- **Then** preview shows list of tasks that will be created:
  - Task name (placeholders replaced)
  - Due date, priority, estimated hours
- **And** user can review before confirming generation

**AC10: Batch Generation for Multiple Clients**
- **Given** an admin wants to generate tasks for all clients with a service
- **When** they use bulk generation interface
- **Then** tasks are generated for all matching client-service combinations
- **And** progress bar shows generation progress
- **And** summary report shows results per client

**AC11: Notification to Assignee**
- **Given** a task is auto-generated
- **When** task creation completes
- **Then** assignee receives notification: "New task: Q1 VAT Return assigned to you"
- **And** notification links to task detail page

### Functional Requirements - Workflow Triggers (FR18)

**AC12: Workflow Stage Completion Trigger**
- **Given** a workflow stage is completed (stage.status → "completed")
- **When** completion webhook/trigger fires
- **Then** system checks for associated templates in workflowTemplates table
- **And** if templates exist, task generation is triggered

**AC13: Workflow Template Configuration**
- **Given** an admin configures a workflow
- **When** they assign templates to workflow stages
- **Then** workflowTemplates records are created
- **And** trigger type is specified: "on_stage_complete" | "on_workflow_start" | "on_workflow_complete"

**AC14: Workflow Dashboard Integration**
- **Given** workflow completion generates tasks
- **When** workflow dashboard is viewed
- **Then** auto-generated tasks are shown per workflow stage
- **And** generation status is displayed (5 tasks generated)

**AC15: Workflow Completion Loop**
- **Given** a workflow stage completes
- **When** next stage tasks are generated
- **Then** workflow progresses automatically to next stage
- **And** staff are notified of new tasks
- **And** complete automation loop is achieved

### Integration Requirements

**AC16: Multi-tenant Isolation**
- **Given** multiple tenants in the system
- **When** tasks are generated
- **Then** all queries filter by tenantId
- **And** generated tasks are scoped to tenant

**AC17: Service Component Integration**
- **Given** templates are assigned to service components
- **When** service is activated
- **Then** correct templates are queried via serviceComponentId
- **And** tasks are generated for that specific component

### Quality Requirements

**AC18: Performance**
- **Given** 50 tasks are generated
- **When** generation runs
- **Then** all tasks are created in <5 seconds
- **And** database operations use bulk insert for performance

**AC19: Error Handling**
- **Given** task generation fails (validation error, database error)
- **When** error occurs
- **Then** transaction rolls back (no partial generation)
- **And** error message shows which template/service failed
- **And** user can retry generation

---

## Technical Implementation

### Database Schema Changes

```typescript
// Add to tasks table
export const tasks = pgTable("tasks", {
  // ... existing fields
  autoGenerated: boolean("auto_generated").default(false),
  templateId: text("template_id").references(() => taskTemplates.id),
  generatedAt: timestamp("generated_at"),
  // ... other fields
});

// workflowTemplates table
export const workflowTemplates = pgTable("workflow_templates", {
  id: text("id").primaryKey(),
  tenantId: text("tenant_id").references(() => tenants.id).notNull(),
  workflowId: text("workflow_id").references(() => workflows.id).notNull(),
  stageId: text("stage_id"),
  templateId: text("template_id").references(() => taskTemplates.id).notNull(),
  triggerType: text("trigger_type").notNull(), // "on_stage_complete" | "on_workflow_start" | "on_workflow_complete"
});
```

### tRPC Procedures

```typescript
// app/server/routers/tasks.ts

export const tasksRouter = router({
  // Generate tasks from template
  generateFromTemplate: protectedProcedure
    .input(z.object({
      templateId: z.string(),
      clientId: z.string(),
      serviceId: z.string(),
      activationDate: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      // Fetch template
      const template = await db.select().from(taskTemplates)
        .where(eq(taskTemplates.id, input.templateId))
        .limit(1);

      if (template.length === 0) {
        throw new TRPCError({ code: "NOT_FOUND" });
      }

      // Fetch client and service for placeholder data
      const client = await db.select().from(clients)
        .where(eq(clients.id, input.clientId))
        .limit(1);

      const service = await db.select().from(services)
        .where(eq(services.id, input.serviceId))
        .limit(1);

      // Build placeholder data
      const placeholderData = {
        clientName: client[0].companyName,
        serviceName: service[0].name,
        companyNumber: client[0].companiesHouseNumber,
        activationDate: input.activationDate ? new Date(input.activationDate) : new Date(),
      };

      // Replace placeholders
      const taskName = replacePlaceholders(template[0].namePattern, placeholderData);
      const taskDescription = template[0].descriptionPattern
        ? replacePlaceholders(template[0].descriptionPattern, placeholderData)
        : undefined;

      // Calculate due date
      const dueDate = calculateDueDate(
        placeholderData.activationDate,
        template[0].dueDateOffsetDays,
        template[0].dueDateOffsetMonths
      );

      // Check for duplicate
      const existingTask = await db.select().from(tasks)
        .where(
          and(
            eq(tasks.tenantId, ctx.authContext.tenantId),
            eq(tasks.clientId, input.clientId),
            eq(tasks.serviceId, input.serviceId),
            eq(tasks.title, taskName)
          )
        )
        .limit(1);

      if (existingTask.length > 0) {
        return { success: false, skipped: true, reason: "Duplicate task exists" };
      }

      // Create task
      const taskId = crypto.randomUUID();
      await db.insert(tasks).values({
        id: taskId,
        tenantId: ctx.authContext.tenantId,
        clientId: input.clientId,
        serviceId: input.serviceId,
        title: taskName,
        description: taskDescription,
        priority: template[0].priority,
        taskType: template[0].taskType,
        estimatedHours: template[0].estimatedHours,
        dueDate: dueDate.toISOString(),
        targetDate: new Date(dueDate.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString(),
        assignedTo: client[0].assignedToId || null,
        autoGenerated: true,
        templateId: input.templateId,
        generatedAt: new Date(),
      });

      // Send notification to assignee
      if (client[0].assignedToId) {
        await db.insert(notifications).values({
          id: crypto.randomUUID(),
          tenantId: ctx.authContext.tenantId,
          userId: client[0].assignedToId,
          type: "task_assigned",
          title: "New task generated",
          message: `Task "${taskName}" has been automatically assigned to you`,
          link: `/client-hub/tasks/${taskId}`,
          read: false,
        });
      }

      return { success: true, taskId };
    }),

  // Generate recurring tasks
  generateRecurringTasks: protectedProcedure
    .input(z.object({
      templateId: z.string(),
      clientId: z.string(),
      serviceId: z.string(),
      periods: z.number().default(4), // Number of periods to generate ahead
    }))
    .mutation(async ({ ctx, input }) => {
      const generatedTasks: string[] = [];

      for (let i = 0; i < input.periods; i++) {
        // Generate task for each period
        // ... (similar to generateFromTemplate with period offset)
      }

      return { success: true, generated: generatedTasks.length };
    }),

  // Preview generation
  previewGeneration: protectedProcedure
    .input(z.object({
      serviceId: z.string(),
      clientId: z.string(),
    }))
    .query(async ({ ctx, input }) => {
      // Fetch templates for service
      // Return preview of tasks that would be generated
      // ... (similar to generateFromTemplate but no database write)
    }),
});
```

### Technical Notes

- **Deduplication:** Check by (clientId, serviceId, task name) to prevent duplicates
- **Bulk Insert:** Use Drizzle batch insert for performance when generating multiple tasks
- **Transaction Safety:** Wrap generation in transaction to rollback on error
- **Webhook Integration:** Use tRPC mutation chaining for workflow triggers

---

## Definition of Done

- [ ] All acceptance criteria met and tested
- [ ] tasks table updated with autoGenerated, templateId, generatedAt fields
- [ ] workflowTemplates table created
- [ ] generateFromTemplate mutation functional
- [ ] Placeholder replacement with actual client/service data
- [ ] Due date calculation from offsets
- [ ] Task deduplication logic
- [ ] Recurring task support
- [ ] Auto-assignment to client manager
- [ ] "Generate Tasks" button in service detail page
- [ ] Generation preview modal
- [ ] Batch generation for multiple clients
- [ ] Notification to assignee when task generated
- [ ] Workflow stage completion trigger
- [ ] Workflow template configuration interface
- [ ] Workflow dashboard showing auto-generated tasks
- [ ] Multi-tenant isolation verified
- [ ] Performance benchmarks met (<5s for 50 tasks)
- [ ] Unit/integration/E2E tests written
- [ ] Seed data updated with auto-generated tasks
- [ ] Documentation updated
- [ ] Feature deployed to staging and tested

---

## Dependencies

**Upstream:**
- Epic 3 STORY-1: Task Templates (required for this story)

**Downstream:**
- None

**External:**
- date-fns (already installed in STORY-3.1)

---

## Testing Strategy

### Unit Tests
- Test placeholder replacement with various placeholders
- Test due date calculation with different offsets
- Test deduplication logic
- Test recurring task generation

### Integration Tests
- Test service activation triggers task generation
- Test workflow completion triggers task generation
- Test batch generation for multiple clients

### E2E Tests
- Test full workflow: create template → assign to service → activate service → tasks generated
- Test generation preview → confirm → tasks created

---

## Risks & Mitigation

**Risk:** Duplicate task generation bugs
**Mitigation:** Comprehensive deduplication logic; generation preview; dry-run mode; extensive unit tests
**Impact:** Medium - duplicate tasks require manual cleanup

**Risk:** Performance issues with bulk generation
**Mitigation:** Use database batch insert; async job queue for large batches; progress tracking
**Impact:** Low - batch operations optimized

---

## Notes

- Task generation eliminates manual task creation for recurring workflows
- Deduplication prevents accidental duplicate generation
- Workflow triggers complete automation loop (service activation → task generation → completion → next stage)
- Auto-assignment ensures tasks go to correct staff member

---

**Story Owner:** Development Team
**Created:** 2025-10-22
**Epic:** EPIC-3 - Advanced Automation Features
**Related PRD:** `/root/projects/practice-hub/docs/prd.md` (FR14 + FR18)
