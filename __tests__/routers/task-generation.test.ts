/**
 * Task Generation Router Integration Tests
 *
 * Integration-level tests for the task-generation tRPC router.
 * Tests verify database operations, tenant isolation, and business logic for AC1-AC11.
 *
 * Cleanup Strategy: Unique test IDs + afterEach cleanup
 */

import { TRPCError } from "@trpc/server";
import { and, eq } from "drizzle-orm";
import { afterEach, beforeEach, describe, expect, it } from "vitest";
import type { Context } from "@/app/server/context";
import { taskGenerationRouter } from "@/app/server/routers/task-generation";
import { db } from "@/lib/db";
import {
  clientServices,
  services,
  taskTemplates,
  tasks,
} from "@/lib/db/schema";
import {
  cleanupTestData,
  createTestClient,
  createTestTenant,
  createTestUser,
  type TestDataTracker,
} from "../helpers/factories";
import { createCaller, createMockContext } from "../helpers/trpc";

describe("app/server/routers/task-generation.ts (Integration)", () => {
  let ctx: Context;
  let caller: ReturnType<typeof createCaller<typeof taskGenerationRouter>>;
  const tracker: TestDataTracker = {
    tenants: [],
    users: [],
    clients: [],
    services: [],
    taskTemplates: [],
    tasks: [],
  };

  let testTenantId: string;
  let testUserId: string;
  let testClientId: string;
  let testServiceId: string;
  let testTemplateId: string;

  beforeEach(async () => {
    // Create test tenant and user
    testTenantId = await createTestTenant();
    testUserId = await createTestUser(testTenantId, { role: "admin" });

    tracker.tenants?.push(testTenantId);
    tracker.users?.push(testUserId);

    // Create mock context
    ctx = createMockContext({
      authContext: {
        userId: testUserId,
        tenantId: testTenantId,
        organizationName: "Test Organization",
        role: "admin",
        email: `test-${Date.now()}@example.com`,
        firstName: "Test",
        lastName: "User",
      },
    });

    caller = createCaller(taskGenerationRouter, ctx);

    // Create test client
    const client = await createTestClient(testTenantId, testUserId);
    testClientId = client.id;
    tracker.clients?.push(testClientId);

    // Create test service
    const [service] = await db
      .insert(services)
      .values({
        id: crypto.randomUUID(),
        tenantId: testTenantId,
        code: `SRV-${Date.now()}`,
        name: "Test VAT Service",
        category: "compliance",
        pricingModel: "fixed",
        isActive: true,
      })
      .returning();
    testServiceId = service.id;
    tracker.services?.push(testServiceId);

    // Link client to service
    await db.insert(clientServices).values({
      id: crypto.randomUUID(),
      tenantId: testTenantId,
      clientId: testClientId,
      serviceId: testServiceId,
      isActive: true,
    });

    // Create test template
    const [template] = await db
      .insert(taskTemplates)
      .values({
        id: crypto.randomUUID(),
        tenantId: testTenantId,
        serviceId: testServiceId,
        namePattern: "VAT Q{period} - {client_name}",
        descriptionPattern: "Complete VAT for {client_name}",
        priority: "high",
        taskType: "compliance",
        estimatedHours: 2,
        dueDateOffsetMonths: 1,
        dueDateOffsetDays: 0,
        isRecurring: true,
        recurringFrequency: "quarterly",
        createdBy: testUserId,
      })
      .returning();
    testTemplateId = template.id;
    tracker.taskTemplates?.push(testTemplateId);
  });

  afterEach(async () => {
    await cleanupTestData(tracker);
    tracker.tenants = [];
    tracker.users = [];
    tracker.clients = [];
    tracker.services = [];
    tracker.taskTemplates = [];
    tracker.tasks = [];
  });

  describe("generateFromTemplate (AC1-AC7)", () => {
    it("should generate a task from template", async () => {
      const result = await caller.generateFromTemplate({
        templateId: testTemplateId,
        clientId: testClientId,
        serviceId: testServiceId,
      });

      expect(result.success).toBe(true);
      expect(result.taskId).toBeDefined();

      // Verify task was created in database
      const [createdTask] = await db
        .select()
        .from(tasks)
        .where(eq(tasks.id, result.taskId!))
        .limit(1);

      expect(createdTask).toBeDefined();
      expect(createdTask.tenantId).toBe(testTenantId);
      expect(createdTask.clientId).toBe(testClientId);
      expect(createdTask.serviceId).toBe(testServiceId);
      expect(createdTask.templateId).toBe(testTemplateId);
      expect(createdTask.autoGenerated).toBe(true);
      expect(createdTask.title).toContain("VAT Q");
      expect(createdTask.priority).toBe("high");
    });

    it("should skip duplicate task (AC4)", async () => {
      // Generate first task
      const firstResult = await caller.generateFromTemplate({
        templateId: testTemplateId,
        clientId: testClientId,
        serviceId: testServiceId,
      });
      expect(firstResult.success).toBe(true);

      // Try to generate again (should skip)
      const secondResult = await caller.generateFromTemplate({
        templateId: testTemplateId,
        clientId: testClientId,
        serviceId: testServiceId,
      });

      expect(secondResult.success).toBe(false);
      expect(secondResult.skipped).toBe(true);
      expect(secondResult.reason).toContain("Duplicate");
    });

    it("should enforce tenant isolation", async () => {
      // Create another tenant
      const otherTenantId = await createTestTenant();
      tracker.tenants?.push(otherTenantId);

      // Try to generate task using template from another tenant
      await expect(
        caller.generateFromTemplate({
          templateId: testTemplateId,
          clientId: testClientId,
          serviceId: testServiceId,
        }),
      ).rejects.toThrow();
    });

    it("should throw error for non-existent template", async () => {
      await expect(
        caller.generateFromTemplate({
          templateId: crypto.randomUUID(),
          clientId: testClientId,
          serviceId: testServiceId,
        }),
      ).rejects.toThrow(TRPCError);
    });

    it("should support custom activation date", async () => {
      const customDate = new Date("2025-06-01");

      const result = await caller.generateFromTemplate({
        templateId: testTemplateId,
        clientId: testClientId,
        serviceId: testServiceId,
        activationDate: customDate.toISOString(),
      });

      expect(result.success).toBe(true);

      // Verify due date is calculated from custom activation date
      const [createdTask] = await db
        .select()
        .from(tasks)
        .where(eq(tasks.id, result.taskId!))
        .limit(1);

      expect(createdTask.dueDate).toBeDefined();
      const dueDate = new Date(createdTask.dueDate!);
      expect(dueDate.getFullYear()).toBe(2025);
      expect(dueDate.getMonth()).toBeGreaterThanOrEqual(5); // June or later
    });
  });

  describe("previewGeneration (AC8, AC9)", () => {
    it("should preview tasks before generation", async () => {
      const preview = await caller.previewGeneration({
        serviceId: testServiceId,
        clientId: testClientId,
      });

      expect(preview).toHaveLength(1);
      expect(preview[0].templateId).toBe(testTemplateId);
      expect(preview[0].taskName).toContain("VAT Q");
      expect(preview[0].priority).toBe("high");
      expect(preview[0].taskType).toBe("compliance");
      expect(preview[0].dueDate).toBeDefined();
      expect(preview[0].isRecurring).toBe(true);
    });

    it("should return empty array when no templates exist", async () => {
      // Delete template
      await db
        .delete(taskTemplates)
        .where(eq(taskTemplates.id, testTemplateId));

      const preview = await caller.previewGeneration({
        serviceId: testServiceId,
        clientId: testClientId,
      });

      expect(preview).toHaveLength(0);
    });

    it("should enforce tenant isolation", async () => {
      // Create another tenant
      const otherTenantId = await createTestTenant();
      tracker.tenants?.push(otherTenantId);

      const otherUserId = await createTestUser(otherTenantId, { role: "admin" });
      tracker.users?.push(otherUserId);

      const otherCtx = createMockContext({
        authContext: {
          userId: otherUserId,
          tenantId: otherTenantId,
          organizationName: "Other Org",
          role: "admin",
          email: "other@example.com",
          firstName: "Other",
          lastName: "User",
        },
      });

      const otherCaller = createCaller(taskGenerationRouter, otherCtx);

      // Should return empty array (not templates from first tenant)
      const preview = await otherCaller.previewGeneration({
        serviceId: testServiceId,
        clientId: testClientId,
      });

      expect(preview).toHaveLength(0);
    });
  });

  describe("bulkGenerateForService (AC10, AC19)", () => {
    let testClient2Id: string;

    beforeEach(async () => {
      // Create second client for bulk generation
      const client2 = await createTestClient(testTenantId, testUserId);
      testClient2Id = client2.id;
      tracker.clients?.push(testClient2Id);

      // Link second client to service
      await db.insert(clientServices).values({
        id: crypto.randomUUID(),
        tenantId: testTenantId,
        clientId: testClient2Id,
        serviceId: testServiceId,
        isActive: true,
      });
    });

    it("should generate tasks for multiple clients", async () => {
      const result = await caller.bulkGenerateForService({
        serviceId: testServiceId,
        clientIds: [testClientId, testClient2Id],
      });

      expect(result.generated).toBe(2);
      expect(result.skipped).toBe(0);
      expect(result.failed).toBe(0);
      expect(result.details).toHaveLength(2);

      // Verify both tasks were created
      const createdTasks = await db
        .select()
        .from(tasks)
        .where(
          and(
            eq(tasks.tenantId, testTenantId),
            eq(tasks.serviceId, testServiceId),
          ),
        );

      expect(createdTasks).toHaveLength(2);
      expect(createdTasks.every((t) => t.autoGenerated === true)).toBe(true);
    });

    it("should generate tasks for all service clients when no clientIds provided", async () => {
      const result = await caller.bulkGenerateForService({
        serviceId: testServiceId,
      });

      // Should generate for both clients linked to service
      expect(result.generated).toBe(2);
    });

    it("should rollback transaction on error (AC19)", async () => {
      // Try to generate with an invalid client ID
      await expect(
        caller.bulkGenerateForService({
          serviceId: testServiceId,
          clientIds: [testClientId, "invalid-client-id"],
        }),
      ).rejects.toThrow();

      // Verify no partial tasks were created (transaction rolled back)
      const tasksAfterError = await db
        .select()
        .from(tasks)
        .where(
          and(
            eq(tasks.tenantId, testTenantId),
            eq(tasks.serviceId, testServiceId),
          ),
        );

      expect(tasksAfterError).toHaveLength(0);
    });

    it("should skip existing tasks in bulk generation", async () => {
      // Generate for first client
      await caller.generateFromTemplate({
        templateId: testTemplateId,
        clientId: testClientId,
        serviceId: testServiceId,
      });

      // Bulk generate for both clients
      const result = await caller.bulkGenerateForService({
        serviceId: testServiceId,
        clientIds: [testClientId, testClient2Id],
      });

      expect(result.generated).toBe(1); // Only second client
      expect(result.skipped).toBe(1); // First client skipped
      expect(result.details.filter((d) => d.status === "skipped")).toHaveLength(1);
    });

    it("should enforce tenant isolation in bulk generation", async () => {
      // Create another tenant
      const otherTenantId = await createTestTenant();
      tracker.tenants?.push(otherTenantId);

      const otherUserId = await createTestUser(otherTenantId, { role: "admin" });
      tracker.users?.push(otherUserId);

      const otherCtx = createMockContext({
        authContext: {
          userId: otherUserId,
          tenantId: otherTenantId,
          organizationName: "Other Org",
          role: "admin",
          email: "other@example.com",
          firstName: "Other",
          lastName: "User",
        },
      });

      const otherCaller = createCaller(taskGenerationRouter, otherCtx);

      // Try to generate for clients in first tenant (should fail/return 0)
      await expect(
        otherCaller.bulkGenerateForService({
          serviceId: testServiceId,
          clientIds: [testClientId, testClient2Id],
        }),
      ).rejects.toThrow();
    });
  });

  describe("generateRecurringTasks (AC5)", () => {
    it("should generate multiple periods for recurring templates", async () => {
      const result = await caller.generateRecurringTasks({
        templateId: testTemplateId,
        clientId: testClientId,
        serviceId: testServiceId,
        periods: 3, // Generate for 3 quarters
      });

      expect(result.generated).toBe(3);
      expect(result.skipped).toBe(0);

      // Verify 3 tasks were created with different periods
      const createdTasks = await db
        .select()
        .from(tasks)
        .where(
          and(
            eq(tasks.tenantId, testTenantId),
            eq(tasks.clientId, testClientId),
            eq(tasks.templateId, testTemplateId),
          ),
        );

      expect(createdTasks).toHaveLength(3);

      // Verify they have different due dates
      const dueDates = createdTasks.map((t) =>
        new Date(t.dueDate!).getTime(),
      );
      const uniqueDueDates = new Set(dueDates);
      expect(uniqueDueDates.size).toBe(3);
    });

    it("should skip duplicate periods in recurring generation", async () => {
      // Generate first period
      await caller.generateFromTemplate({
        templateId: testTemplateId,
        clientId: testClientId,
        serviceId: testServiceId,
      });

      // Generate 3 periods (first should be skipped)
      const result = await caller.generateRecurringTasks({
        templateId: testTemplateId,
        clientId: testClientId,
        serviceId: testServiceId,
        periods: 3,
      });

      expect(result.generated).toBe(2); // Only periods 2 and 3
      expect(result.skipped).toBe(1); // Period 1 skipped
    });

    it("should throw error for non-recurring template", async () => {
      // Create non-recurring template
      const [nonRecurringTemplate] = await db
        .insert(taskTemplates)
        .values({
          id: crypto.randomUUID(),
          tenantId: testTenantId,
          serviceId: testServiceId,
          namePattern: "One-time Task - {client_name}",
          priority: "medium",
          taskType: "consultation",
          isRecurring: false,
          recurringFrequency: null,
          createdBy: testUserId,
        })
        .returning();

      tracker.taskTemplates?.push(nonRecurringTemplate.id);

      await expect(
        caller.generateRecurringTasks({
          templateId: nonRecurringTemplate.id,
          clientId: testClientId,
          serviceId: testServiceId,
          periods: 3,
        }),
      ).rejects.toThrow(TRPCError);
    });
  });
});
